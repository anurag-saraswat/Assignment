# -*- coding: utf-8 -*-
"""ML2_Assignment2_Q2_a.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10MPSQVXNg120yFqS0Zv7U5F585l6uunr

# 2. Download a ResNet 50 trained on the ImageNet classification dataset, 
a. Use the features extracted from the last fully-connected layer and train
binary SVM classifier for a category [from CIFAR-10 categories] of your
choice. Report the following

- Accuracy, Confusion Matrix on test data. 
- ROC curve (assuming the chosen class as positive class and
remaining classes as negative)
"""

# Importing library


import numpy as np
import matplotlib.pyplot as plt

import torch
import torchvision
import torch.optim as optim
import torchvision.transforms as transforms
import torch.nn as nn
import torch.nn.functional as F
import torchvision.models as models

from sklearn.svm import LinearSVC
from sklearn.pipeline import make_pipeline
from sklearn.preprocessing import StandardScaler

# Downloading and Loading Data Set

transform = transforms.Compose([transforms.ToTensor(),transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])

trainset = torchvision.datasets.CIFAR10(root='./data', train=True,download=True, transform=transform)
trainloader = torch.utils.data.DataLoader(trainset, batch_size=50000,shuffle=True, num_workers=2)

testset = torchvision.datasets.CIFAR10(root='./data', train=False,download=True, transform=transform)
testloader = torch.utils.data.DataLoader(testset, batch_size=10000, shuffle=False, num_workers=2)

classes = ('plane', 'car', 'bird', 'cat','deer', 'dog', 'frog', 'horse', 'ship', 'truck')

# Initializing GPU
device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")
print(device)

"""##a. Use the features extracted from the last fully-connected layer and train binary SVM classifier for a category [from CIFAR-10 categories] of your choice. Report the following

- Accuracy, Confusion Matrix on test data. 
- ROC curve (assuming the chosen class as positive class and
remaining classes as negative) 
"""

net = torch.hub.load('pytorch/vision:v0.6.0', 'resnet50', pretrained=True)
net.to(device)
for param in net.parameters():
    param.requires_grad = False

"""Passing Train Data from Resnet"""

with torch.no_grad():
    for data in trainloader:
        images, labels = data[0].to(device), data[1].to(device)
        outputs = net(images)

# Setting labels of class 2 to 1 and rest to 0
# Bird Class versus rest Classification
for i in range(labels.shape[0]):
  if (labels[i] != 2):
    labels[i] = 0
  else:
    labels[i] = 1
print(labels)

"""Passing Train Data from SVM"""

x = np.array(outputs.cpu())
l = np.array(labels.cpu())

clf = make_pipeline(StandardScaler(),LinearSVC(random_state = 0, tol=1e-5))
clf.fit(x[:25000],l[:25000])

#Passing Test data from Resnet
with torch.no_grad():
    for data in testloader:
        imagesTest, labelsTest = data[0].to(device), data[1].to(device)
        outputsTest = net(imagesTest)

for i in range(labelsTest.shape[0]):
  if (labelsTest[i] != 2):
    labelsTest[i] = 0
  else:
    labelsTest[i] = 1
print(labelsTest)

c = np.array(outputsTest.cpu())
d = np.array(labelsTest.cpu())

# Finding Accuracy Using Test Data
total = 0
correct = 0

confusion_matrix = [[0,0],[0,0]]

tpr = []
fpr = []


y_pred = clf.predict(c)

for i in range(10000):

  #Calculating TPR and FPR after 100 sample
  t = confusion_matrix[0][0]/(confusion_matrix[0][0] + confusion_matrix[0][1] +0.0001)
  f = confusion_matrix[0][1]/(confusion_matrix[1][1] + confusion_matrix[0][1]+ 0.0001)

  tpr.append(t)
  fpr.append(f)

  confusion_matrix[d[i]][y_pred[i]] += 1
  if (y_pred[i]==d[i]):
    correct +=1
  total +=1

print('-------Confusion Matrix-------')
for i in confusion_matrix:
  for j in i:
    print(j,end='   ')
  print()

Accuracy = (correct/total)*100
print('Accuracy on test data is :', Accuracy)

import pandas as pd
import seaborn as sn
import matplotlib.pyplot as plt

plt.figure(num=None, figsize=(8, 6), dpi=80, facecolor='w', edgecolor='k')


x_axis_labels= ['Non-Bird','Bird']
y_axis_labels= ['Non-Bird','Bird']


sn.heatmap(confusion_matrix, annot=True, xticklabels=x_axis_labels, yticklabels=y_axis_labels,cmap='Blues', fmt='g')
plt.xlabel("Prediction")
plt.ylabel("Labels")
plt.title('Confusion Matrix')
plt.savefig('./Confusion_matrix')
plt.show()

# ROC CURVE {receiver operating characteristic curve}
import pandas as pd
import matplotlib.pyplot as plt

plt.figure(num=None, figsize=(8, 6), dpi=80, facecolor='w', edgecolor='k')

plt.plot(fpr[:500],tpr[:500])
plt.xlabel("FPR")
plt.ylabel("TPR")
plt.title('ROC CURVE')
plt.savefig('./ROC_CURVE')
plt.show()

from  sklearn.metrics import roc_curve

fpr, tpr, thresholds = roc_curve(y_pred, d)

# ROC CURVE {receiver operating characteristic curve}
import pandas as pd
import matplotlib.pyplot as plt

plt.figure(num=None, figsize=(8, 6), dpi=80, facecolor='w', edgecolor='k')

plt.plot(fpr,tpr)
plt.xlabel("FPR")
plt.ylabel("TPR")
plt.title('ROC CURVE')
plt.savefig('./ROC_CURVE')
plt.show()

